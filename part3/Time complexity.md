### 核心总结表 (时间复杂度)

| 数据结构 | 查 (Access/Search) | 增 (Insert) | 删 (Delete) | 改 (Update) |
| :--- | :--- | :--- | :--- | :--- |
| **数组 (Array)** | $O(1)$ (索引)<br>$O(n)$ (值) | $O(n)$ | $O(n)$ | $O(1)$ (索引) |
| **单链表** | $O(n)$ | $O(1)$ (头插)<br>$O(n)$ (指定位置) | $O(1)$ (头删)<br>$O(n)$ (指定位置) | $O(n)$ |
| **双链表** | $O(n)$ | $O(1)$ (头尾)<br>$O(n)$ (指定位置) | $O(1)$ (头尾)<br>$O(n)$ (指定位置) | $O(n)$ |
| **栈 (Array)** | $O(1)$ (Top) | $O(1)$ (Push) | $O(1)$ (Pop) | N/A |
| **栈 (Linked)** | $O(1)$ (Top) | $O(1)$ (Push) | $O(1)$ (Pop) | N/A |
| **队列 (Linked)** | $O(1)$ (Head/Tail) | $O(1)$ (Enqueue) | $O(1)$ (Dequeue) | N/A |
| **二叉搜索树 (BST)** | 平均 $O(\log n)$<br>最差 $O(n)$ | 平均 $O(\log n)$<br>最差 $O(n)$ | 平均 $O(\log n)$<br>最差 $O(n)$ | 平均 $O(\log n)$<br>最差 $O(n)$ |

---

### 简单理由说明

#### 1. 数组 (Array)
*   **查/改 ($O(1)$ by Index):** 数组在内存中是**连续存储**的。只要知道数组首地址和下标，通过公式 `地址 = 首地址 + 索引 * 元素大小` 直接就能定位，不需要遍历。
*   **增/删 ($O(n)$):** 假如你在数组中间插入或删除一个元素，为了保持“连续性”，后面的所有元素都必须**整体向后移动**或**向前移动**，所以最坏情况要操作 $n$ 个元素。

#### 2. 单链表 (Singly Linked List)
*   **查/改 ($O(n)$):** 内存不连续，通过指针连接。要找第 $k$ 个元素，必须从头节点顺着指针**一个一个往后找**，无法直接计算地址。
*   **增/删:**
    *   **头尾操作 ($O(1)$):** 如果只在头部操作，只需修改头指针，非常快。
    *   **指定位置 ($O(n)$):** 虽然指针断开重连的操作是 $O(1)$，但你首先得**花 $O(n)$ 的时间找到那个位置**。

#### 3. 双链表 (Doubly Linked List)
*   **查/改 ($O(n)$):** 依然需要遍历查找。
*   **增/删:**
    *   **相比单链表的优势:** 双链表有 `prev` 指针。在删除节点时，如果你已经拿到了要删除的节点指针，单链表还需要遍历去找它的“前驱节点” ($O(n)$)，但双链表可以直接通过 `prev` 找到前驱，实现 $O(1)$ 删除（前提是已知节点位置）。
    *   **一般情况:** 如果是按索引增删，瓶颈依然在“查找位置”上，所以整体还是 $O(n)$。

#### 4. 栈 (Stack) - 无论是 Array 还是 Linked
*   **特性:** 先进后出 (LIFO)，只允许在**一端**进行操作。
*   **增/删/查 ($O(1)$):**
    *   **Array版:** 用一个变量记录 `top` 索引，直接访问、赋值、`top++` 或 `top--`，无需移动数据。
    *   **Linked版:** 相当于只对链表进行**头插**和**头删**，不需要遍历，直接操作指针。

#### 5. 队列 (Queue) - Linked List 实现
*   **特性:** 先进先出 (FIFO)，一头进，另一头出。
*   **增/删/查 ($O(1)$):** 我们通常维护两个指针：`head` (头) 和 `tail` (尾)。
    *   **入队:** 直接在 `tail` 后连上新节点，更新 `tail`，不需遍历。
    *   **出队:** 直接把 `head` 指向下一个节点，不需遍历。

#### 6. 二叉搜索树 (BST)
*   **特性:** 左子树所有节点 < 根节点 < 右子树所有节点。
*   **增/删/改/查 (平均 $O(\log n)$):**
    *   每次比较都能**排除掉一半**的数据（向左走就不看右边，向右走就不看左边）。这和二分查找的逻辑一样，取决于树的高度 $h$。
*   **最差情况 ($O(n)$):**
    *   如果插入的数据是有序的（比如 1, 2, 3, 4, 5），树会退化成一条**“链表”**。此时没有了“排除一半”的优势，每次只能往下走一步，复杂度退化为 $O(n)$。
    *   *注：为了解决这个问题，通常会使用 AVL 树或红黑树等平衡二叉树，保证最差也是 $O(\log n)$。*